# 任务调度系统功能介绍手册

## 1. 系统架构

本任务调度系统采用模块化设计，主要包含以下几个核心模块：

- **任务调度器**：负责任务的创建、调度和管理
- **CPU利用率监控**：实时计算和统计系统及各任务的CPU使用情况
- **内存池管理**：提供固定大小内存块的分配和释放，避免内存碎片
- **硬件抽象层**：提供与硬件相关的基础功能，如延时、LED控制等

## 2. 任务调度模块

### 2.1 设计思路

任务调度模块采用基于优先级队列（有序链表）的设计，根据任务的下次执行时间进行排序，确保任务按照预期的时间间隔执行。系统使用链表结构存储待执行的任务，链表按任务的下次执行时间升序排列。

### 2.2 核心功能

#### 2.2.1 任务控制块

每个任务都有一个对应的任务控制块（Task Control Block, TCB），包含以下信息：

```c
typedef struct {
    void (*task_func)(void);  // 任务函数指针
    uint32_t interval;        // 执行间隔（毫秒）
    uint32_t last_run;        // 上次执行时间
    uint32_t max_exec_time;   // 最大执行时间
    uint32_t actual_exec_time; // 实际执行时间
    TaskState state;          // 任务状态
    const char *name;         // 任务名称
    uint8_t is_active;        // 任务是否激活
} Task_t;
```

#### 2.2.2 任务状态管理

系统支持三种任务状态：

- **TASK_READY**：任务就绪，等待执行
- **TASK_RUNNING**：任务正在执行中
- **TASK_SUSPENDED**：任务被挂起，不参与调度

#### 2.2.3 任务链表

系统使用链表结构存储待执行的任务节点：

```c
typedef struct TaskNode {
    TaskID id;                  // 任务ID
    uint32_t next_run_time;     // 下次执行时间
    struct TaskNode* next;      // 指向下一个节点
} TaskNode;
```

任务节点按下次执行时间排序，确保最先到期的任务位于链表头部。

#### 2.2.4 系统节拍

系统通过SysTick定时器提供1毫秒的时间基准，每次中断时调用`Task_UpdateTick`函数更新系统时间计数器。

### 2.3 调度算法

任务调度器采用以下算法：

1. 检查链表头部任务是否到达执行时间
2. 如果到达执行时间，移除任务节点并执行任务
3. 记录任务执行时间并更新统计信息
4. 对于周期性任务，重新计算下次执行时间并插入链表
5. 对于一次性任务（interval为0），执行后释放资源

## 3. CPU利用率监控模块

### 3.1 设计思路

CPU利用率监控模块通过记录每个任务的执行时间，定期计算系统和各任务的CPU使用情况。该模块使用64位计数器存储运行时间，避免在长期运行时发生溢出。

### 3.2 核心功能

#### 3.2.1 运行时间统计

系统在每个任务执行前后记录时间戳，计算实际执行时间并累加：

```c
// 记录开始时间
uint32_t start_time = system_time;

// 执行任务
if (task->task_func != NULL) {
    task->task_func();
}

// 计算执行时间
uint32_t exec_time = system_time - start_time;
task->actual_exec_time = exec_time;

// 更新CPU利用率统计
CPUUtil_UpdateTaskRunTime(id, exec_time);
```

#### 3.2.2 利用率计算

CPU利用率计算公式：

```
CPU利用率(%) = (任务总执行时间 / 采样周期) * 100%
```

#### 3.2.3 移动平均滤波

为了平滑CPU利用率的波动，系统使用移动平均滤波算法，给最近的采样值更高的权重。

```c
// 计算加权历史平均值
float avg_usage = 0.0f;
for (uint8_t i = 0; i < CPU_UTIL_HISTORY_SIZE; i++) {
    // 给最近的值更高权重
    uint8_t weight = (CPU_UTIL_HISTORY_SIZE - i);
    avg_usage += cpu_usage_history[(history_index + i) % CPU_UTIL_HISTORY_SIZE] * weight;
}
calculated_usage = avg_usage / ((CPU_UTIL_HISTORY_SIZE * (CPU_UTIL_HISTORY_SIZE + 1)) / 2);
```

## 4. 内存池管理模块

### 4.1 设计思路

内存池管理模块采用固定大小内存块的设计，通过预分配内存和块状态管理，实现高效的内存分配和释放，避免内存碎片问题。

### 4.2 核心功能

#### 4.2.1 内存池结构

内存池包含一个二维数组作为存储区域，以及一个状态数组记录每个块的使用情况：

```c
typedef struct {
    uint8_t pool[MEMPOOL_BLOCK_COUNT][MEMPOOL_BLOCK_SIZE];  // 内存池数据
    bool block_used[MEMPOOL_BLOCK_COUNT];                  // 块使用状态
    uint8_t free_blocks;                                   // 空闲块数量
} MemPool_t;
```

#### 4.2.2 内存分配策略

内存分配采用首次适应算法（First-Fit），查找第一个未使用的内存块：

```c
void* MemPool_Alloc(void) {
    // 查找第一个空闲块
    for (uint8_t i = 0; i < MEMPOOL_BLOCK_COUNT; i++) {
        if (!mem_pool.block_used[i]) {
            // 标记块为已使用
            mem_pool.block_used[i] = true;
            mem_pool.free_blocks--;
            
            return (void*)mem_pool.pool[i];
        }
    }
    
    return 0;  // 没有空闲块
}
```

#### 4.2.3 内存释放

内存释放时，通过指针计算出对应的块索引，并将其标记为未使用：

```c
void MemPool_Free(void* ptr) {
    if (!ptr) return;
    
    // 计算指针所在的块索引
    uint32_t block_index = ((uint8_t*)ptr - (uint8_t*)mem_pool.pool) / MEMPOOL_BLOCK_SIZE;
    
    // 验证索引有效性
    if (block_index < MEMPOOL_BLOCK_COUNT) {
        if (mem_pool.block_used[block_index]) {
            mem_pool.block_used[block_index] = false;
            mem_pool.free_blocks++;
        }
    }
}
```

## 5. 硬件抽象层

### 5.1 LED控制

提供LED灯的初始化和状态控制功能：

- `LED_Config()`：配置LED引脚
- `LED_Turn()`：切换LED状态

### 5.2 按键处理

提供按键扫描和状态检测功能：

- `Key_Init()`：初始化按键引脚
- `Get_Key()`：获取按键状态

### 5.3 OLED显示

提供OLED屏幕的初始化和显示功能：

- `OLED_Init()`：初始化OLED屏幕
- `OLED_UpdateAsync()`：异步更新OLED显示
- `OLED_Clear()`：清除OLED屏幕
- `OLED_Printf()`：在OLED上打印格式化文本

### 5.4 延时函数

提供毫秒级延时功能：

- `Delay_Init()`：初始化延时功能
- `Delay_ms()`：毫秒级延时

## 6. 典型应用场景

### 6.1 周期性任务调度

系统设计用于管理多个周期性任务，如数据采集、显示更新、通信处理等，每个任务可以设置不同的执行频率。

### 6.2 资源监控

通过CPU利用率监控和内存池管理，系统可以实时监控资源使用情况，有助于性能优化和问题诊断。

### 6.3 事件驱动编程

结合按键和其他外部事件，可以实现事件驱动的编程模型，提高系统响应性。

## 7. 系统优化建议

### 7.1 任务设计优化

- 任务函数应尽量简短，避免长时间阻塞
- 对于耗时操作，考虑分割为多个短任务或使用一次性任务
- 避免在任务中使用递归或大量局部变量

### 7.2 内存管理优化

- 根据实际需求调整内存块大小和数量
- 及时释放不再使用的内存块
- 定期检查内存池使用率，避免内存溢出

### 7.3 性能监控

- 定期查看CPU利用率，确保系统负载合理
- 分析各任务的执行时间，优化耗时操作
- 对于关键任务，设置合理的执行间隔以保证实时性