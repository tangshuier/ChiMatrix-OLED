# 任务调度系统详细内容手册

## 1. 系统架构详解

### 1.1 整体架构

本任务调度系统采用分层架构设计，主要分为以下几层：

- **硬件抽象层**：直接与硬件交互，提供基础功能支持
- **系统核心层**：包含任务调度器、CPU监控、内存管理等核心功能
- **应用层**：用户创建的任务和业务逻辑

### 1.2 目录结构

```
├── HardWare\       # 硬件驱动文件
│   ├── LED.c/h
│   ├── OLED.c/h
│   ├── OLED_Data.c/h
│   ├── key.c/h
├── Library\        # STM32标准库
├── System\         # 系统核心功能
│   ├── CPUUtil.c/h # CPU利用率监控
│   ├── Delay.c/h   # 延时函数
│   ├── MemPool.c/h # 内存池管理
│   ├── Task.c/h    # 任务调度器
│   ├── sys.c/h     # 系统配置
├── User\           # 用户应用代码
│   ├── main.c/h
│   ├── stm32f10x_it.c/h
├── Start\          # 启动文件
```

## 2. 任务调度器实现详解

### 2.1 数据结构设计

#### 2.1.1 任务控制块

```c
typedef struct {
    void (*task_func)(void);  // 任务函数指针
    uint32_t interval;        // 执行间隔（毫秒）
    uint32_t last_run;        // 上次执行时间
    uint32_t max_exec_time;   // 最大执行时间
    uint32_t actual_exec_time; // 实际执行时间
    TaskState state;          // 任务状态
    const char *name;         // 任务名称
    uint8_t is_active;        // 任务是否激活
} Task_t;
```

#### 2.1.2 任务节点

```c
typedef struct TaskNode {
    TaskID id;                  // 任务ID
    uint32_t next_run_time;     // 下次执行时间
    struct TaskNode* next;      // 指向下一个节点
} TaskNode;
```

### 2.2 核心算法实现

#### 2.2.1 任务链表插入算法

```c
static void InsertTaskNode(TaskNode* node) {
    // 确保节点的next指针为NULL，避免环形引用
    node->next = NULL;
    
    if (task_list_head == NULL || node->next_run_time < task_list_head->next_run_time) {
        // 插入到链表头部
        node->next = task_list_head;
        task_list_head = node;
    } else {
        // 插入到链表中间或尾部
        TaskNode* current = task_list_head;
        while (current->next != NULL && current->next->next_run_time <= node->next_run_time) {
            current = current->next;
        }
        node->next = current->next;
        current->next = node;
    }
}
```

#### 2.2.2 任务调度器实现

```c
void Task_RunScheduler(void) {
    // 检查是否有任务需要执行
    if (task_list_head != NULL && system_time >= task_list_head->next_run_time) {
        TaskNode* node = task_list_head;
        TaskID id = node->id;
        
        // 从链表中移除当前节点
        task_list_head = node->next;
        
        // 检查任务ID有效性
        if (id < MAX_TASKS) {
            Task_t* task = &tasks[id];
            
            // 检查任务状态和有效性
            if (task->is_active && task->state == TASK_READY) {
                // 记录开始时间
                uint32_t start_time = system_time;
                
                // 设置任务状态为运行中
                task->state = TASK_RUNNING;
                
                // 执行任务函数
                if (task->task_func != NULL) {
                    task->task_func();
                }
                
                // 计算并更新执行时间
                uint32_t exec_time = system_time - start_time;
                task->actual_exec_time = exec_time;
                
                // 更新最大执行时间
                if (exec_time > task->max_exec_time) {
                    task->max_exec_time = exec_time;
                }
                
                // 更新CPU利用率统计
                CPUUtil_UpdateTaskRunTime(id, exec_time);
                
                // 更新任务状态和时间
                task->last_run = system_time;
                task->state = TASK_READY;
                
                // 检查任务是否为一次性任务
                if (task->interval == 0) {
                    // 一次性任务，释放资源
                    Task_NodeFree(node);
                    task_nodes[id] = NULL;
                    task->is_active = 0;
                } else {
                    // 周期性任务，重新计算下次执行时间并插入链表
                    node->next_run_time = system_time + task->interval;
                    InsertTaskNode(node);
                }
            } else if (task->is_active) {
                // 任务存在但未就绪，重新插入链表
                InsertTaskNode(node);
            } else {
                // 任务已无效，释放节点
                Task_NodeFree(node);
                task_nodes[id] = NULL;
            }
        } else {
            // ID无效，释放节点
            Task_NodeFree(node);
        }
    }
}
```

### 2.3 任务管理API详解

#### 2.3.1 Task_Init

```c
/**
 * @brief 初始化任务系统
 * @note 必须在添加任何任务前调用
 */
void Task_Init(void) {
    // 初始化任务数组
    memset(tasks, 0, sizeof(tasks));
    
    // 初始化任务节点映射表
    for (TaskID i = 0; i < MAX_TASKS; i++) {
        task_nodes[i] = NULL;
    }
    
    // 初始化链表头
    task_list_head = NULL;
}
```

#### 2.3.2 Task_Add

```c
/**
 * @brief 添加新任务
 * @param task_func 任务函数指针（void func(void)形式）
 * @param interval 执行间隔（毫秒），0表示每次调度循环都执行
 * @param name 任务名称（用于调试）
 * @return TaskID 分配的任务ID（INVALID_TASK_ID表示添加失败）
 */
TaskID Task_Add(void (*task_func)(void), 
               uint32_t interval, 
               const char *name) {
    // 参数检查
    if (task_func == NULL) {
        return INVALID_TASK_ID;
    }
    
    // 遍历任务槽寻找空闲位置
    for (TaskID i = 0; i < MAX_TASKS; i++) {
        if (!tasks[i].is_active) {
            // 从内存池分配任务节点
            TaskNode* node = Task_NodeAlloc();
            if (node == NULL) {
                return INVALID_TASK_ID;  // 内存池已满
            }
            
            // 初始化任务结构体
            tasks[i].task_func = task_func;
            tasks[i].interval = interval;
            tasks[i].last_run = system_time;
            tasks[i].max_exec_time = 0;
            tasks[i].actual_exec_time = 0;
            tasks[i].state = TASK_READY;
            tasks[i].name = name;
            tasks[i].is_active = 1;
            
            // 初始化任务节点
            node->id = i;
            node->next_run_time = system_time + interval;
            node->next = NULL;
            
            // 将节点插入到有序链表中
            InsertTaskNode(node);
            
            // 更新任务节点映射表
            task_nodes[i] = node;
            
            return i;
        }
    }
    return INVALID_TASK_ID; // 无可用任务槽
}
```

#### 2.3.3 Task_Suspend

```c
/**
 * @brief 挂起任务
 * @param id 要挂起的任务ID
 * 
 * 功能：
 * 1. 设置任务状态为挂起
 * 2. 从链表中移除任务节点（避免挂起任务占用链表资源）
 */
void Task_Suspend(TaskID id) {
    // 参数有效性检查
    if (id < MAX_TASKS && tasks[id].is_active) {
        // 设置任务状态为挂起
        tasks[id].state = TASK_SUSPENDED;
        
        // 从链表中移除节点但不释放，保留在内存池中
        TaskNode* node = RemoveTaskNodeNoFree(id);
        // 注意：挂起时不释放节点，保留节点指针供Resume使用
        if (node != NULL) {
            task_nodes[id] = node;
        }
    }
}
```

#### 2.3.4 Task_Resume

```c
/**
 * @brief 恢复被挂起的任务
 * @param id 要恢复的任务ID
 * 
 * 功能：
 * 1. 设置任务状态为就绪
 * 2. 重新计算下次执行时间并排序
 */
void Task_Resume(TaskID id) {
    // 参数有效性检查
    if (id >= MAX_TASKS || !tasks[id].is_active || task_nodes[id] == NULL) {
        return;
    }
    
    // 设置任务状态为就绪
    tasks[id].state = TASK_READY;
    
    // 获取挂起时保存的节点
    TaskNode* node = task_nodes[id];
    
    // 先从链表中移除节点（如果已存在）
    TaskNode* temp = RemoveTaskNodeNoFree(id);
    if (temp != NULL) {
        node = temp;
        task_nodes[id] = node;
    }
    
    // 更新下次执行时间
    node->next_run_time = system_time + tasks[id].interval;
    
    // 插入到有序链表
    InsertTaskNode(node);
}
```

## 3. CPU利用率监控实现详解

### 3.1 数据结构设计

```c
// CPU利用率数据结构
typedef struct {
    uint64_t total_run_time;        // 总运行时间(使用64位防止溢出)
    uint64_t task_run_time[MAX_TASKS]; // 每个任务的运行时间
    float cpu_usage;                // CPU总体利用率(%)
    float task_usage[MAX_TASKS];    // 每个任务的CPU利用率(%)
    uint32_t last_sample_time;      // 上次采样时间
} CPUUtil_t;
```

### 3.2 核心算法实现

#### 3.2.1 CPU利用率计算

```c
float CPUUtil_Calculate(void) {
    // 计算从上次采样到现在的时间差
    uint32_t current_time = system_time;
    uint32_t elapsed_time;
    
    if (current_time >= cpu_util.last_sample_time) {
        elapsed_time = current_time - cpu_util.last_sample_time;
    } else {
        // 处理系统时间溢出
        elapsed_time = 0xFFFFFFFF - cpu_util.last_sample_time + current_time + 1;
    }
    
    // 确保有足够的时间差进行有效计算
    if (elapsed_time < 10) {
        return cpu_util.cpu_usage;
    }
    
    // 计算总体CPU利用率
    float calculated_usage = 0.0f;
    
    if (elapsed_time > 0) {
        // 使用64位整数和float计算
        calculated_usage = (float)cpu_util.total_run_time * 100.0f / elapsed_time;
        
        // 确保利用率不超过100%
        if (calculated_usage > 100.0f) {
            calculated_usage = 100.0;
        }
        
        // 应用移动平均滤波以平滑波动
        cpu_usage_history[history_index] = calculated_usage;
        history_index = (history_index + 1) % CPU_UTIL_HISTORY_SIZE;
        
        // 计算加权历史平均值
        float avg_usage = 0.0f;
        for (uint8_t i = 0; i < CPU_UTIL_HISTORY_SIZE; i++) {
            uint8_t weight = (CPU_UTIL_HISTORY_SIZE - i);
            avg_usage += cpu_usage_history[(history_index + i) % CPU_UTIL_HISTORY_SIZE] * weight;
        }
        calculated_usage = avg_usage / ((CPU_UTIL_HISTORY_SIZE * (CPU_UTIL_HISTORY_SIZE + 1)) / 2);
        
        // 更新全局CPU利用率
        cpu_util.cpu_usage = calculated_usage;
        
        // 计算每个任务的CPU利用率
        for (TaskID i = 0; i < MAX_TASKS; i++) {
            if (cpu_util.task_run_time[i] > 0 && elapsed_time > 0) {
                cpu_util.task_usage[i] = (float)cpu_util.task_run_time[i] * 100.0f / elapsed_time;
            } else {
                cpu_util.task_usage[i] = 0.0f;
            }
        }
    }
    
    // 重置计数器，准备下一次采样
    cpu_util.total_run_time = 0;
    memset(cpu_util.task_run_time, 0, sizeof(cpu_util.task_run_time));
    cpu_util.last_sample_time = current_time;
    
    return calculated_usage;
}
```

### 3.3 运行时间更新

```c
void CPUUtil_UpdateTaskRunTime(TaskID task_id, uint32_t run_time) {
    if (task_id < MAX_TASKS) {
        // 使用64位整数可以有效防止溢出
        cpu_util.task_run_time[task_id] += run_time;
        cpu_util.total_run_time += run_time;
    }
}
```

## 4. 内存池管理实现详解

### 4.1 数据结构设计

```c
// 内存池结构
typedef struct {
    uint8_t pool[MEMPOOL_BLOCK_COUNT][MEMPOOL_BLOCK_SIZE];  // 内存池数据
    bool block_used[MEMPOOL_BLOCK_COUNT];                  // 块使用状态
    uint8_t free_blocks;                                   // 空闲块数量
} MemPool_t;
```

### 4.2 核心算法实现

#### 4.2.1 内存池初始化

```c
void MemPool_Init(void) {
    // 初始化所有块为未使用状态
    for (uint8_t i = 0; i < MEMPOOL_BLOCK_COUNT; i++) {
        mem_pool.block_used[i] = false;
    }
    mem_pool.free_blocks = MEMPOOL_BLOCK_COUNT;
}
```

#### 4.2.2 内存分配

```c
void* MemPool_Alloc(void) {
    // 查找第一个空闲块
    for (uint8_t i = 0; i < MEMPOOL_BLOCK_COUNT; i++) {
        if (!mem_pool.block_used[i]) {
            // 标记块为已使用
            mem_pool.block_used[i] = true;
            mem_pool.free_blocks--;
            
            return (void*)mem_pool.pool[i];
        }
    }
    
    return 0;  // 没有空闲块
}
```

#### 4.2.3 内存释放

```c
void MemPool_Free(void* ptr) {
    // 检查指针是否有效
    if (!ptr) return;
    
    // 计算指针所在的块索引
    uint32_t block_index = ((uint8_t*)ptr - (uint8_t*)mem_pool.pool) / MEMPOOL_BLOCK_SIZE;
    
    // 验证索引有效性
    if (block_index < MEMPOOL_BLOCK_COUNT) {
        if (mem_pool.block_used[block_index]) {
            mem_pool.block_used[block_index] = false;
            mem_pool.free_blocks++;
        }
    }
}
```

## 5. 完整API文档

### 5.1 任务管理API

#### Task_Init
- **功能**：初始化任务系统
- **参数**：无
- **返回值**：无
- **调用时机**：在添加任何任务前调用

#### Task_Add
- **功能**：添加新的周期性任务
- **参数**：
  - `task_func`：任务函数指针（void func(void)形式）
  - `interval`：执行间隔（毫秒）
  - `name`：任务名称（用于调试）
- **返回值**：任务ID（0-9），INVALID_TASK_ID表示失败

#### Task_AddOneShot
- **功能**：添加一次性任务
- **参数**：
  - `task_func`：任务函数指针
  - `delay`：延迟执行时间（毫秒）
  - `name`：任务名称
- **返回值**：任务ID

#### Task_Remove
- **功能**：删除任务
- **参数**：`id`：要删除的任务ID
- **返回值**：无

#### Task_Suspend
- **功能**：挂起任务
- **参数**：`id`：要挂起的任务ID
- **返回值**：无

#### Task_Resume
- **功能**：恢复被挂起的任务
- **参数**：`id`：要恢复的任务ID
- **返回值**：无

#### Task_ChangeInterval
- **功能**：修改任务执行间隔
- **参数**：
  - `id`：任务ID
  - `new_interval`：新的执行间隔（毫秒）
- **返回值**：无

#### Task_RunScheduler
- **功能**：运行任务调度器
- **参数**：无
- **返回值**：无
- **调用时机**：在主循环中不断调用

#### Task_GetSystemTime
- **功能**：获取当前系统时间
- **参数**：无
- **返回值**：系统时间（毫秒）

#### Task_GetActualRunInterval
- **功能**：获取指定任务的实际执行时间
- **参数**：`id`：任务ID
- **返回值**：任务实际执行时间（毫秒）

### 5.2 CPU利用率监控API

#### CPUUtil_Init
- **功能**：初始化CPU利用率计算模块
- **参数**：无
- **返回值**：无

#### CPUUtil_UpdateTaskRunTime
- **功能**：更新任务运行时间
- **参数**：
  - `task_id`：任务ID
  - `run_time`：本次运行的时间
- **返回值**：无

#### CPUUtil_Calculate
- **功能**：计算CPU利用率
- **参数**：无
- **返回值**：当前CPU总体利用率(%)

#### CPUUtil_GetTaskUsage
- **功能**：获取指定任务的CPU利用率
- **参数**：`task_id`：任务ID
- **返回值**：任务的CPU利用率(%)

#### CPUUtil_GetTotalUsage
- **功能**：获取总体CPU利用率
- **参数**：无
- **返回值**：总体CPU利用率(%)

#### CPUUtil_CalculateTask
- **功能**：CPU利用率计算任务函数
- **参数**：无
- **返回值**：无
- **用途**：定期计算并更新CPU利用率，需添加为任务

### 5.3 内存池管理API

#### MemPool_Init
- **功能**：初始化内存池
- **参数**：无
- **返回值**：无

#### MemPool_Alloc
- **功能**：从内存池分配一个内存块
- **参数**：无
- **返回值**：分配的内存块指针，失败返回NULL

#### MemPool_Free
- **功能**：释放内存块回内存池
- **参数**：`ptr`：要释放的内存块指针
- **返回值**：无

#### MemPool_GetUsage
- **功能**：获取内存池使用率
- **参数**：无
- **返回值**：内存池使用率（百分比）

## 6. 示例代码

### 6.1 基本任务创建和管理

```c
#include "stm32f10x.h"
#include "Task.h"
#include "CPUUtil.h"
#include "MemPool.h"
#include "Delay.h"
#include "LED.h"

TaskID blinkTaskID, monitorTaskID;

// LED闪烁任务
void BlinkTask(void) {
    LED_Turn();
}

// 系统监控任务
void MonitorTask(void) {
    float cpu_usage = CPUUtil_GetTotalUsage();
    float mem_usage = MemPool_GetUsage();
    
    // 这里可以添加显示代码或其他监控逻辑
    
    // 动态调整闪烁任务的执行间隔
    static uint32_t counter = 0;
    counter++;
    if (counter >= 10) {  // 每10秒调整一次
        counter = 0;
        if (cpu_usage > 50.0f) {
            // CPU负载高，降低闪烁频率
            Task_ChangeInterval(blinkTaskID, 500);
        } else {
            // CPU负载正常，恢复闪烁频率
            Task_ChangeInterval(blinkTaskID, 100);
        }
    }
}

// 一次性任务示例
void OneShotTask(void) {
    // 执行一些只需要执行一次的初始化操作
    LED_Turn();  // 闪烁一次表示任务执行
}

int main(void) {
    // 系统初始化
    SystemInit();
    Delay_Init();
    LED_Config();
    
    // 任务系统初始化
    MemPool_Init();
    Task_Init();
    
    // CPU利用率监控初始化
    CPUUtil_Init();
    
    // 添加任务
    blinkTaskID = Task_Add(BlinkTask, 100, "BlinkTask");  // 每100ms闪烁一次
    monitorTaskID = Task_Add(MonitorTask, 1000, "MonitorTask");  // 每1秒监控一次
    
    // 添加CPU利用率计算任务
    Task_Add(CPUUtil_CalculateTask, 500, "CPUUtil");
    
    // 添加一次性任务，2秒后执行
    Task_AddOneShot(OneShotTask, 2000, "OneShotInit");
    
    // 主循环
    while(1) {
        Task_RunScheduler();
    }
}
```

### 6.2 任务挂起和恢复示例

```c
#include "stm32f10x.h"
#include "Task.h"
#include "key.h"

TaskID periodicTaskID;

// 周期性任务
void PeriodicTask(void) {
    // 执行周期性操作
}

// 按键处理任务
void KeyTask(void) {
    uint8_t key = Get_Key();
    
    switch(key) {
        case 1:  // 按键1：挂起周期性任务
            Task_Suspend(periodicTaskID);
            break;
        case 2:  // 按键2：恢复周期性任务
            Task_Resume(periodicTaskID);
            break;
        default:
            break;
    }
}

int main(void) {
    // 初始化
    SystemInit();
    Key_Init();
    MemPool_Init();
    Task_Init();
    
    // 添加任务
    periodicTaskID = Task_Add(PeriodicTask, 50, "PeriodicTask");
    Task_Add(KeyTask, 10, "KeyTask");
    
    // 主循环
    while(1) {
        Task_RunScheduler();
    }
}
```

### 6.3 内存池使用示例

```c
#include "stm32f10x.h"
#include "MemPool.h"

// 数据结构体
typedef struct {
    uint32_t timestamp;
    uint16_t value;
    uint8_t status;
} SensorData;

void ProcessSensorData(void) {
    // 从内存池分配内存
    void* mem_block = MemPool_Alloc();
    
    if (mem_block != NULL) {
        // 将分配的内存块用于SensorData结构体
        SensorData* data = (SensorData*)mem_block;
        
        // 使用分配的内存
        data->timestamp = 0;  // 这里应该设置实际的时间戳
        data->value = 123;    // 这里应该设置实际的传感器值
        data->status = 1;     // 正常状态
        
        // 处理数据...
        
        // 使用完毕后释放内存
        MemPool_Free(mem_block);
    } else {
        // 内存分配失败，处理错误
    }
}
```

## 7. 性能优化指南

### 7.1 任务优化

1. **任务粒度**：任务函数应尽量简短，执行时间控制在10ms以内
2. **避免阻塞**：任务中应避免使用长延时函数，使用任务间隔代替
3. **优先级设计**：虽然系统目前按时间排序，但可以通过合理设置执行间隔来模拟优先级
4. **资源共享**：多个任务共享资源时，应使用原子操作或信号量机制（需扩展实现）

### 7.2 内存优化

1. **内存池配置**：根据实际需求调整`MEMPOOL_BLOCK_SIZE`和`MEMPOOL_BLOCK_COUNT`
2. **内存使用**：避免在任务中频繁分配和释放内存，尽量在初始化时分配
3. **内存检查**：定期检查内存池使用率，避免内存溢出
4. **结构体对齐**：优化数据结构设计，减少内存对齐浪费

### 7.3 系统优化

1. **时钟配置**：根据系统需求合理配置系统时钟频率
2. **中断管理**：合理设置中断优先级，避免中断嵌套过深
3. **缓存利用**：对于频繁访问的数据，考虑使用局部变量缓存
4. **代码优化**：使用编译器优化选项，减少代码大小和执行时间

## 8. 故障排除

### 8.1 常见问题及解决方案

1. **任务不执行**
   - 检查任务是否正确添加（返回值是否为有效ID）
   - 检查任务函数是否正确实现（无参数无返回值）
   - 确认任务调度器是否在主循环中调用

2. **任务执行时间过长**
   - 检查任务函数中是否有长延时或死循环
   - 考虑将长任务分割为多个短任务

3. **内存分配失败**
   - 检查内存池是否已初始化
   - 检查是否有足够的空闲内存块
   - 确认是否正确释放了之前分配的内存

4. **CPU利用率异常高**
   - 检查是否有任务执行时间过长
   - 检查是否有任务间隔设置过小
   - 使用`CPUUtil_GetTaskUsage()`查看各个任务的CPU占用

5. **系统不稳定**
   - 检查栈空间是否足够
   - 确认系统时钟配置是否正确
   - 检查中断处理是否正确

### 8.2 调试技巧

1. **LED调试**：使用LED闪烁表示程序运行状态和任务执行
2. **时间测量**：使用`Task_GetSystemTime()`测量代码执行时间
3. **任务状态检查**：定期输出任务状态和执行时间信息
4. **断言机制**：在关键位置添加断言，及早发现问题

## 9. 系统扩展建议

### 9.1 功能扩展

1. **信号量机制**：添加信号量实现任务间同步
2. **互斥锁**：实现资源互斥访问
3. **消息队列**：添加消息队列实现任务间通信
4. **优先级调度**：增强调度器，支持真正的优先级调度
5. **软件定时器**：实现基于任务的软件定时器功能

### 9.2 硬件扩展

1. **串口调试**：添加串口调试功能，输出系统状态信息
2. **实时时钟**：集成RTC模块，提供精确的时间戳
3. **外部存储**：支持SD卡或Flash存储，保存系统日志
4. **通信接口**：添加I2C、SPI、CAN等通信接口的任务封装

### 9.3 安全增强

1. **堆栈溢出检测**：添加堆栈溢出检测机制
2. **看门狗集成**：完善独立看门狗配置，增强系统可靠性
3. **错误恢复**：实现任务错误自动恢复机制
4. **日志系统**：添加系统日志功能，记录关键事件和错误